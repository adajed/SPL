module Main where

import System.IO
import System.FilePath
import System.Environment ( getArgs, getProgName )
import System.Exit ( exitFailure, exitSuccess )
import System.Process

import Control.Monad ( liftM, when )

import Data.Map as Map

import LexSPL
import ParSPL
import SkelSPL
import PrintSPL
import AbsSPL

import ArgParse
import CodeM
import Defs ( Pos )
import ExprTypeCheck ( typeProgram )
import GenerateIR ( runGenerateIR )
import GenCode ( genCode )
import ErrM
import IR
import BasicBlock
import Optimizations
import StaticCheck
import SSA

type ParseFun a = [Token] -> Err a

myLLexer :: String -> [Token]
myLLexer = myLexer

removeExtension :: FilePath -> FilePath
removeExtension filepath =
    let dir = takeDirectory filepath
        basename = takeBaseName filepath
     in dir ++ "/" ++ basename

changeExtension :: FilePath -> String -> FilePath
changeExtension filepath ext =
    let dir = takeDirectory filepath
        basename = takeBaseName filepath
     in dir ++ "/" ++ basename ++ "." ++ ext

writeIR :: Handle -> (Ident, [IR]) -> IO ()
writeIR h (fName, xs) = do
    hPutStrLn h ("; " ++ show fName ++ "\n")
    hPutStrLn h (show fName ++ ":")
    let f (IR_Label l) = hPutStrLn h (show l ++ ":")
        f ir = hPutStrLn h ("\t" ++ show ir)
    mapM_ f xs
    hPutStrLn h "\n"

writeCodeMap :: Handle -> Map Ident [Code] -> IO ()
writeCodeMap h codeMap = do
    hPutStrLn h "; Generated by SPL compiler\n"
    hPutStrLn h "\textern printInt"
    hPutStrLn h "\textern allocMemory"
    hPutStrLn h ""
    hPutStrLn h "\tsection .text\n"
    mapM_ (writeCode h) (Map.assocs codeMap)

writeCode :: Handle -> (Ident, [Code]) -> IO ()
writeCode h (fName, xs) = do
    hPutStrLn h ("; " ++ show fName ++ "\n")
    hPutStrLn h ("\tglobal " ++ show fName ++ "\n")
    hPutStrLn h (show fName ++ ":")
    let f (CLabel l) = hPutStrLn h (show l ++ ":")
        f c = hPutStrLn h ("\t" ++ show c)
    mapM_ f xs
    hPutStrLn h ""

compileProgram :: ParseFun (Program a) -> String -> Err (Program (), Map Ident [IR], Map Ident [Code])
compileProgram parser fileContent = do
    let abstractTree = myLLexer fileContent
    program <- liftM (fmap (const ())) $ parser abstractTree
    staticCheck program
    program <- typeProgram program
    code <- runGenerateIR program
    ir <- liftM (Map.map layoutBBGraph) $ mapM optimizeCode code
    let code = Map.map genCode ir
    return (fmap (const ()) program, Map.map fst ir, code)


optimizeCode :: [IR] -> Err BBGraph
optimizeCode code = do
    g <- toSSA (splitIntoBasicBlocks code)
    return (removePhi (optimize g))

run :: ParseFun (Program a) -> Bool -> Bool -> String -> IO ()
run parser bShowTree bSaveIR filepath = do
    hPutStrLn stderr ("Compiling " ++ filepath)
    fileContent <- readFile filepath
    let abstractTree = myLLexer fileContent
    case compileProgram parser fileContent of
      Bad errorMsg -> do
          hPutStrLn stderr errorMsg
          exitFailure
      Ok (program, ir, code) -> do
          when bShowTree (hPutStrLn stdout (printTree program))
          let fileIR = changeExtension filepath "ir"
          let fileCode = changeExtension filepath "s"
          let fileObj = changeExtension filepath "o"
          let fileOut = removeExtension filepath
          when bSaveIR (do
              handleIR <- openFile fileIR WriteMode
              mapM_ (writeIR handleIR) (Map.assocs ir)
              hClose handleIR)
          handleCode <- openFile fileCode WriteMode
          writeCodeMap handleCode code
          hClose handleCode
          callCommand ("nasm -felf64 -o " ++ fileObj ++ " " ++ fileCode)
          callCommand ("gcc -no-pie -o " ++ fileOut ++ " " ++ fileObj ++ " lib/runtime.o")

main :: IO ()
main = do
  args <- getArgs
  case args of
    [] -> do
        hPutStrLn stderr "Usage: ./spl source-files"
        exitFailure
    _ -> do
        let a = parseArgs args
        let aShowTree = ArgParse.showTree a
        let bSaveIR = saveIR a
        let aFilePaths = filepaths a
        mapM_ (run pProgram aShowTree bSaveIR) aFilePaths
