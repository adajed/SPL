module Main where

import System.IO
import System.FilePath
import System.Environment ( getArgs, getProgName )
import System.Exit ( exitFailure, exitSuccess )
import System.Process

import Control.Monad ( liftM, when )

import qualified Data.Map as M
import qualified Data.Set as S

import LexSPL
import ParSPL
import PrintSPL
import AbsSPL

import ArgParse
import CalculateLiveVars
import CodeM
import FinishOptimizations
import GenIR
import GenerateIR ( runGenerateIR )
import GenCode ( genCode )
import GraphColoring ( allocateRegisters )
import ErrM
import IR
import BasicBlock
import Optimizations
import Token
import StaticCheck
import SSA

type Parser = [Token] -> Err (Program Pos)

parser :: Parser
parser = parseProgram

lexer :: String -> [Token]
lexer = myLexer

removeExtension :: FilePath -> FilePath
removeExtension filepath =
    let dir = takeDirectory filepath
        basename = takeBaseName filepath
     in dir ++ "/" ++ basename

changeExtension :: FilePath -> String -> FilePath
changeExtension filepath ext =
    let dir = takeDirectory filepath
        basename = takeBaseName filepath
     in dir ++ "/" ++ basename ++ "." ++ ext

writeIR_BBGraph :: Handle -> BBGraph -> IO ()
writeIR_BBGraph h g = do
    let liveVars = calculateLiveVars g
    let t = "\t\t\t\t\t\t\t\t"
    let bbs = flattenBBGraph g
    let m ir v = hPutStrLn h ("\t" ++ show ir ++ "\n" ++ t ++ show (S.toList v))
    let showBB (BB name xs) vars = do
                              hPutStrLn h (show name ++ ":")
                              hPutStrLn h (t ++ show (S.toList (head vars)))
                              mapM_ (uncurry m) (zip xs (tail vars))
    let showI i = showBB ((ids g) M.! i) (liveVars M.! i)
    mapM_ showI bbs


writeIR :: Handle -> Bool -> (VIdent, BBGraph) -> IO ()
writeIR h allocRegisters (fName, g) = do
    let (g', regs) = allocateRegisters allocRegisters g
    hPutStrLn h (show fName ++ ":")
    writeIR_BBGraph h g'
    hPutStrLn h "register allocations:\n"
    let showR (x, r) = hPutStrLn h (show x ++ " -> " ++ show r)
    mapM_ showR (M.assocs regs)
    hPutStrLn h "\n\n"

writeCodeMap :: Handle -> M.Map VIdent [Code] -> IO ()
writeCodeMap h codeMap = do
    hPutStrLn h "; Generated by SPL compiler\n"
    hPutStrLn h "\textern printInt"
    hPutStrLn h "\textern print"
    hPutStrLn h "\textern allocMemory"
    hPutStrLn h "\textern freeMemory"
    hPutStrLn h ""
    hPutStrLn h "\tsection .text\n"
    mapM_ (writeCode h) (M.assocs codeMap)

writeCode :: Handle -> (VIdent, [Code]) -> IO ()
writeCode h (fName, xs) = do
    hPutStrLn h ("; " ++ show fName ++ "\n")
    hPutStrLn h ("\tglobal " ++ show fName ++ "\n")
    hPutStrLn h (show fName ++ ":")
    let f (CLabel l) = hPutStrLn h (show l ++ ":")
        f c = hPutStrLn h ("\t" ++ show c)
    mapM_ f xs
    hPutStrLn h ""

writeIRData :: Handle -> (VIdent, [DataIR]) -> IO ()
writeIRData h (fName, xs) = do
    hPutStrLn h ("; " ++ show fName ++ "\n")
    hPutStrLn h (show fName ++ ":")
    let f c = hPutStrLn h ("\t" ++ show c)
    mapM_ f xs
    hPutStrLn h ""

compileProgram :: OptimizationOptions -> String -> Err (Program (), M.Map VIdent BBGraph,  M.Map VIdent [Code], ProgramIR)
compileProgram options fileContent = do
    let abstractTree = lexer fileContent
    program <- parser abstractTree
    program' <- staticCheck program
    programir <- runGenerateIR program'
    ir <- optimizeCode options (textSection programir)
    let code = M.map (genCode (doRegisterAllocation options))  ir
    return (fmap (const ()) program, ir, code, programir)


optimizeCode :: OptimizationOptions -> M.Map VIdent [IR] -> Err (M.Map VIdent BBGraph)
optimizeCode options p = do
    let p' = M.mapWithKey splitIntoBasicBlocks p
    p <- mapM toSSA p'
    p <- return (basicOptimize options p)
    p <- return (optimize options p)
    p <- return (M.map finishOptimizations p)
    return p


getNasmCommand :: Args -> FilePath -> FilePath -> String
getNasmCommand args fileOut fileCode = "nasm " ++ nasm_args ++ " -o " ++ fileOut ++ " " ++ fileCode
    where nasm_args = "-felf64" ++ debug
          debug = if debugBuild args then " -g" else ""


getGccCommand :: Args -> FilePath -> FilePath -> String
getGccCommand args fileOut fileObj = "gcc " ++ gcc_args ++ " -o " ++ fileOut ++ " " ++ fileObj ++ " lib/runtime.o"
    where gcc_args = "-no-pie" ++ debug
          debug = if debugBuild args then " -g" else ""


run :: Args -> String -> IO ()
run args filepath = do
    let options = optimizationOptions args
    hPutStrLn stderr ("Compiling " ++ filepath)
    fileContent <- readFile filepath
    case compileProgram options fileContent of
      Bad errorMsg -> do
          hPutStrLn stderr errorMsg
          exitFailure
      Ok (program, ir, code, programir) -> do
          when (showTree args) (hPutStrLn stdout (printTree program))
          let codeir = textSection programir
          let datair = dataSection programir
          let fileIR = changeExtension filepath "ir"
          let fileCode = changeExtension filepath "s"
          let fileObj = changeExtension filepath "o"
          let fileOut = removeExtension filepath
          when (saveIR args) (do
              mapM_ (mapM_ ((hPutStrLn stdout) . show)) codeir
              hPutStrLn stdout (show codeir)
              handleIR <- openFile fileIR WriteMode
              mapM_ (writeIR handleIR (doRegisterAllocation options)) (M.assocs ir)
              mapM_ (writeIRData handleIR) (M.assocs datair)
              hClose handleIR)
          handleCode <- openFile fileCode WriteMode
          writeCodeMap handleCode code
          hPutStrLn handleCode "\tsection .data\n"
          mapM_ (writeIRData handleCode) (M.assocs datair)
          hClose handleCode
          hPutStrLn stdout (getNasmCommand args fileObj fileCode)
          hPutStrLn stdout (getGccCommand args fileOut fileObj)

main :: IO ()
main = do
  args <- getArgs
  case args of
    [] -> do
        hPutStrLn stderr "Usage: ./spl source-files"
        exitFailure
    _ -> do
        a <- parseArgs args
        let aFilePaths = filepaths a
        mapM_ (run a) aFilePaths
