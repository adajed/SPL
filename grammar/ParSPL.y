-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParSPL where
import AbsSPL
import LexSPL
import ErrM
import Operator
import Token
import Type

}

%name pProgram Program
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '!'       { PT _ (T_Keyword _ 1) }
  '!='      { PT _ (T_Keyword _ 2) }
  '%'       { PT _ (T_Keyword _ 3) }
  '&'       { PT _ (T_Keyword _ 4) }
  '&&'      { PT _ (T_Keyword _ 5) }
  '('       { PT _ (T_Keyword _ 6) }
  ')'       { PT _ (T_Keyword _ 7) }
  '*'       { PT _ (T_Keyword _ 8) }
  '+'       { PT _ (T_Keyword _ 9) }
  '++'      { PT _ (T_Keyword _ 10) }
  ','       { PT _ (T_Keyword _ 11) }
  '-'       { PT _ (T_Keyword _ 12) }
  '--'      { PT _ (T_Keyword _ 13) }
  '->'      { PT _ (T_Keyword _ 14) }
  '.'       { PT _ (T_Keyword _ 15) }
  '/'       { PT _ (T_Keyword _ 16) }
  ';'       { PT _ (T_Keyword _ 17) }
  '<'       { PT _ (T_Keyword _ 18) }
  '<<'      { PT _ (T_Keyword _ 19) }
  '<='      { PT _ (T_Keyword _ 20) }
  '='       { PT _ (T_Keyword _ 21) }
  '=='      { PT _ (T_Keyword _ 22) }
  '>'       { PT _ (T_Keyword _ 23) }
  '>='      { PT _ (T_Keyword _ 24) }
  '>>'      { PT _ (T_Keyword _ 25) }
  '['       { PT _ (T_Keyword _ 26) }
  '[]'      { PT _ (T_Keyword _ 27) }
  '\\'      { PT _ (T_Keyword _ 28) }
  ']'       { PT _ (T_Keyword _ 29) }
  '^'       { PT _ (T_Keyword _ 30) }
  'bool'    { PT _ (T_Keyword _ 31) }
  'class'   { PT _ (T_Keyword _ 32) }
  'else'    { PT _ (T_Keyword _ 33) }
  'false'   { PT _ (T_Keyword _ 34) }
  'if'      { PT _ (T_Keyword _ 35) }
  'int'     { PT _ (T_Keyword _ 36) }
  'new'     { PT _ (T_Keyword _ 37) }
  'null'    { PT _ (T_Keyword _ 38) }
  'return'  { PT _ (T_Keyword _ 39) }
  'true'    { PT _ (T_Keyword _ 40) }
  'void'    { PT _ (T_Keyword _ 41) }
  'while'   { PT _ (T_Keyword _ 42) }
  '{'       { PT _ (T_Keyword _ 43) }
  '|'       { PT _ (T_Keyword _ 44) }
  '||'      { PT _ (T_Keyword _ 45) }
  '}'       { PT _ (T_Keyword _ 46) }
  '~'       { PT _ (T_Keyword _ 47) }
  'for'     { PT _ (T_Keyword _ 48) }
  'to'      { PT _ (T_Keyword _ 49) }
  'down'    { PT _ (T_Keyword _ 50) }
  'in'      { PT _ (T_Keyword _ 51) }
  'by'      { PT _ (T_Keyword _ 52) }
  'extends' { PT _ (T_Keyword _ 53) }
  'constr'  { PT _ (T_Keyword _ 54) }
  'then'    { PT _ (T_Keyword _ 55) }
  'typedef' { PT _ (T_Keyword _ 56) }
  'char'    { PT _ (T_Keyword _ 57) }
  'string'  { PT _ (T_Keyword _ 58) }
  'real'    { PT _ (T_Keyword _ 59) }
  'or'      { PT _ (T_Keyword _ 60) }
  'and'     { PT _ (T_Keyword _ 61) }

L_integ  { PT _ (T_Int _) }
L_CIdent { PT _ (T_CIdent _) }
L_VIdent { PT _ (T_VIdent _) }
L_String { PT _ (T_String _) }
L_Char   { PT _ (T_Char _) }


%%

Integer :: { (Pos, Integer) }
: L_integ {
    (Just (tokenLineCol $1), read (prToken $1))
}

String :: { (Pos, String) }
: L_String {
    (Just (tokenLineCol $1), prToken $1)
}

Char :: { (Pos, Char) }
: L_Char {
    (Just (tokenLineCol $1), read (prToken $1))
}

CIdent  :: { (Pos, CIdent) }
: L_CIdent {
    (Just (tokenLineCol $1), CIdent (prToken $1))
}

VIdent  :: { (Pos, VIdent) }
: L_VIdent {
    (Just (tokenLineCol $1), VIdent (prToken $1))
}

Program :: { (Pos, Program Pos) }
Program : ListTopDef { (fst $1, AbsSPL.Prog (fst $1) (snd $1)) }

TopDef :: { (Pos, TopDef Pos) }
TopDef
: Type VIdent '(' ListArgument ')' Block {
    (fst $1, AbsSPL.FnDef (fst $1) (snd $1) (snd $2) (snd $4) (snd $6))
}
| 'typedef' CIdent '=' Type ';' {
    (Just (tokenLineCol $1), AbsSPL.TypeDef (Just (tokenLineCol $1)) (snd $2) (snd $4))
}
| 'class' CIdent '{' ListClassElem '}' {
    (Just (tokenLineCol $1), AbsSPL.ClassDef (Just (tokenLineCol $1)) (snd $2) (AbsSPL.NoExtends Nothing) (reverse (snd $4)))
}
| 'class' CIdent 'extends' CIdent '{' ListClassElem '}' {
    (Just (tokenLineCol $1), AbsSPL.ClassDef (Just (tokenLineCol $1)) (snd $2) (AbsSPL.Extends (fst $4) (snd $4)) (reverse (snd $6)))
}

ListTopDef :: { (Pos, [TopDef Pos]) }
ListTopDef
: TopDef {
    (fst $1, [snd $1])
}
| TopDef ListTopDef {
    (fst $1, ((:) (snd $1) (snd $2)))
}

Argument :: { (Pos, Argument Pos) }
Argument
: Type VIdent {
    (fst $1, AbsSPL.Arg (fst $1) (snd $1) (snd $2))
}

ListArgument :: { (Pos, [Argument Pos]) }
ListArgument
: {- empty -} {
    (Nothing, [])
}
| Argument {
    (fst $1, [snd $1])
}
| Argument ',' ListArgument {
    (fst $1, (snd $1):(snd $3))
}

ClassElem :: { (Pos, ClassElem Pos) }
ClassElem
: Type ListVIdent ';' {
    (fst $1, AbsSPL.Field (fst $1) (snd $1) (snd $2))
}
| 'constr' '(' ListArgument ')' Block {
    (Just (tokenLineCol $1), AbsSPL.Constr (Just (tokenLineCol $1)) (snd $3) (snd $5))
}
| Type VIdent '(' ListArgument ')' Block {
    (fst $1, AbsSPL.Method (fst $1) (snd $1) (snd $2) (snd $4) (snd $6))
}

ListVIdent :: { (Pos, [VIdent]) }
ListVIdent
: VIdent {
    (fst $1, [snd $1])
}
| VIdent ',' ListVIdent {
    (fst $1, (snd $1):(snd $3))
}

ListClassElem :: { (Pos, [ClassElem Pos]) }
ListClassElem
: {- empty -} {
    (Nothing, [])
}
| ListClassElem ClassElem {
    (fst $1, (snd $2):(snd $1))
}

Block :: { (Pos, Block Pos) }
Block
: '{' ListStmt '}' {
    (Just (tokenLineCol $1), AbsSPL.Bl (Just (tokenLineCol $1)) (reverse (snd $2)))
}

ListStmt :: { (Pos, [Stmt Pos]) }
ListStmt
: {- empty -} {
    (Nothing, [])
}
| ListStmt Stmt {
    (fst $1, (snd $2):(snd $1))
}

Stmt :: { (Pos, Stmt Pos) }
Stmt
: ';' {
    (Just (tokenLineCol $1), AbsSPL.Empty (Just (tokenLineCol $1)))
}
| Block {
    (fst $1, AbsSPL.BStmt (fst $1) (snd $1))
}
| Type ListItem ';' {
    (fst $1, AbsSPL.Decl (fst $1) (snd $1) (snd $2))
}
| Expr '=' Expr ';' {
    (fst $1, AbsSPL.Ass (fst $1) (snd $1) (snd $3))
}
| Expr '++' ';' {
    (fst $1, AbsSPL.Incr (fst $1) (snd $1))
}
| Expr '--' ';' {
    (fst $1, AbsSPL.Decr (fst $1) (snd $1))
}
| 'return' Expr ';' {
    (Just (tokenLineCol $1), AbsSPL.Ret (Just (tokenLineCol $1)) (snd $2))
}
| 'return' ';' {
    (Just (tokenLineCol $1), AbsSPL.VRet (Just (tokenLineCol $1)))
}
| 'if' '(' Expr ')' Stmt {
    (Just (tokenLineCol $1), AbsSPL.Cond (Just (tokenLineCol $1)) (snd $3) (snd $5))
}
| 'if' '(' Expr ')' Stmt 'else' Stmt {
    (Just (tokenLineCol $1), AbsSPL.CondElse (Just (tokenLineCol $1)) (snd $3) (snd $5) (snd $7))
}
| 'while' '(' Expr ')' Stmt {
    (Just (tokenLineCol $1), AbsSPL.While (Just (tokenLineCol $1)) (snd $3) (snd $5))
}
| 'for' '(' VIdent '=' Expr 'to' Expr ')' Stmt {
    (Just (tokenLineCol $1), AbsSPL.ForUp (Just (tokenLineCol $1)) (snd $3) (snd $5) (snd $7) (AbsSPL.EInt Nothing 1) (snd $9))
}
| 'for' '(' VIdent '=' Expr 'to' Expr 'by' Expr ')' Stmt {
    (Just (tokenLineCol $1), AbsSPL.ForUp (Just (tokenLineCol $1)) (snd $3) (snd $5) (snd $7) (snd $9) (snd $11))
}
| 'for' '(' VIdent '=' Expr 'down' 'to' Expr ')' Stmt {
    (Just (tokenLineCol $1), AbsSPL.ForDown (Just (tokenLineCol $1)) (snd $3) (snd $5) (snd $8) (AbsSPL.EInt Nothing 1) (snd $10))
}
| 'for' '(' VIdent '=' Expr 'down' 'to' Expr 'by' Expr ')' Stmt {
    (Just (tokenLineCol $1), AbsSPL.ForUp (Just (tokenLineCol $1)) (snd $3) (snd $5) (snd $8) (snd $10) (snd $12))
}
| 'for' '(' VIdent 'in' Expr ')' Stmt {
    (Just (tokenLineCol $1), AbsSPL.ForEach (Just (tokenLineCol $1)) (snd $3) (snd $5) (snd $7))
}
| Expr ';' {
    (fst $1, AbsSPL.SExp (fst $1) (snd $1))
}

Item :: { (Pos, Item Pos) }
Item
: VIdent {
    (fst $1, AbsSPL.NoInit (fst $1) (snd $1))
}
| VIdent '=' Expr {
    (fst $1, AbsSPL.Init (fst $1) (snd $1) (snd $3))
}

ListItem :: { (Pos, [Item Pos]) }
ListItem
: Item {
    (fst $1, [snd $1])
}
| Item ',' ListItem {
    (fst $1, (snd $1):(snd $3))
}

Type :: { (Pos, Type Pos) }
Type
: 'int' {
    (Just (tokenLineCol $1), Type.Int (Just (tokenLineCol $1)))
}
| 'char' {
    (Just (tokenLineCol $1), Type.Char (Just (tokenLineCol $1)))
}
| 'string' {
    (Just (tokenLineCol $1), Type.Array (Just (tokenLineCol $1)) (Type.Char Nothing))
}
| 'bool' {
    (Just (tokenLineCol $1), Type.Bool (Just (tokenLineCol $1)))
}
| 'void' {
    (Just (tokenLineCol $1), Type.Void (Just (tokenLineCol $1)))
}
| CIdent {
    (fst $1, Type.NamedType (fst $1) (snd $1))
}
| Type '[]' {
    (fst $1, Type.Array (fst $1) (snd $1))
}
| Type '(' ListType ')' {
    (fst $1, Type.Fun (fst $1) (snd $1) (snd $3))
}

ListType :: { (Pos, [Type Pos]) }
ListType
: {- empty -} {
    (Nothing, [])
}
| Type {
    (fst $1, [snd $1])
}
| Type ',' ListType {
    (fst $1, (snd $1):(snd $3))
}

Expr7 :: { (Pos, Expr Pos) }
Expr7
: 'null' {
    (Just (tokenLineCol $1), AbsSPL.ENull (Just (tokenLineCol $1)))
}
| 'true' {
    (Just (tokenLineCol $1), AbsSPL.ETrue (Just (tokenLineCol $1)))
}
| 'false' {
    (Just (tokenLineCol $1), AbsSPL.EFalse (Just (tokenLineCol $1)))
}
| VIdent {
    (fst $1, AbsSPL.EVar (fst $1) (snd $1))
}
| String {
    (fst $1, AbsSPL.EString (fst $1) (snd $1))
}
| Integer {
    (fst $1, AbsSPL.EInt (fst $1) (snd $1))
}
| Char {
    (fst $1, AbsSPL.EChar (fst $1) (snd $1))
}
| Expr7 '.' VIdent {
    (fst $1, AbsSPL.EField (fst $1) (snd $1) (snd $3))
}
| Expr7 '[' Expr ']' {
    (fst $1, AbsSPL.EArrAcc (fst $1) (snd $1) (snd $3))
}
| Expr7 '(' ListExpr ')' {
    (fst $1, AbsSPL.EApp (fst $1) (snd $1) (snd $3))
}
| '(' Expr ')' {
    (Just (tokenLineCol $1), (snd $2))
}

Expr6 :: { (Pos, Expr Pos) }
Expr6
: '-' Expr6 {
    (Just (tokenLineCol $1), AbsSPL.EUnaryOp (Just (tokenLineCol $1)) Neg (snd $2))
}
| '!' Expr6 {
    (Just (tokenLineCol $1), AbsSPL.EUnaryOp (Just (tokenLineCol $1)) Not (snd $2))
}
| '~' Expr6 {
    (Just (tokenLineCol $1), AbsSPL.EUnaryOp (Just (tokenLineCol $1)) BitNot (snd $2))
}
| Expr7 {
    $1
}

Expr5 :: { (Pos, Expr Pos) }
Expr5
: Expr5 '*' Expr6 {
    (fst $1, AbsSPL.EBinOp (fst $1) (snd $1) Times (snd $3))
}
| Expr5 '/' Expr6 {
    (fst $1, AbsSPL.EBinOp (fst $1) (snd $1) Div (snd $3))
}
| Expr5 '%' Expr6 {
    (fst $1, AbsSPL.EBinOp (fst $1) (snd $1) Mod (snd $3))
}
| Expr5 '<<' Expr6 {
    (fst $1, AbsSPL.EBinOp (fst $1) (snd $1) LShift (snd $3))
}
| Expr5 '>>' Expr6 {
    (fst $1, AbsSPL.EBinOp (fst $1) (snd $1) RShift (snd $3))
}
| Expr5 '&' Expr6 {
    (fst $1, AbsSPL.EBinOp (fst $1) (snd $1) BitAnd (snd $3))
}
| Expr5 '|' Expr6 {
    (fst $1, AbsSPL.EBinOp (fst $1) (snd $1) BitOr (snd $3))
}
| Expr5 '^' Expr6 {
    (fst $1, AbsSPL.EBinOp (fst $1) (snd $1) BitXor (snd $3))
}
| Expr6 {
    $1
}

Expr4 :: { (Pos, Expr Pos) }
Expr4
: Expr4 '+' Expr5 {
    (fst $1, AbsSPL.EBinOp (fst $1) (snd $1) Plus (snd $3))
}
| Expr4 '-' Expr5 {
    (fst $1, AbsSPL.EBinOp (fst $1) (snd $1) Minus (snd $3))
}
| Expr5 {
    $1
}

Expr3 :: { (Pos, Expr Pos) }
Expr3
: Expr3 '<' Expr4 {
    (fst $1, AbsSPL.EBinOp (fst $1) (snd $1) Less (snd $3))
}
| Expr3 '<=' Expr4 {
    (fst $1, AbsSPL.EBinOp (fst $1) (snd $1) LessEq (snd $3))
}
| Expr3 '>' Expr4 {
    (fst $1, AbsSPL.EBinOp (fst $1) (snd $1) Greater (snd $3))
}
| Expr3 '>=' Expr4 {
    (fst $1, AbsSPL.EBinOp (fst $1) (snd $1) GreaterEq (snd $3))
}
| Expr3 '==' Expr4 {
    (fst $1, AbsSPL.EBinOp (fst $1) (snd $1) Equal (snd $3))
}
| Expr3 '!=' Expr4 {
    (fst $1, AbsSPL.EBinOp (fst $1) (snd $1) NotEqual (snd $3))
}
| Expr4 {
    $1
}

Expr2 :: { (Pos, Expr Pos) }
Expr2
: Expr3 '&&' Expr2 {
    (fst $1, AbsSPL.EBinOp (fst $1) (snd $1) And (snd $3))
}
| Expr3 'and' Expr2 {
    (fst $1, AbsSPL.EBinOp (fst $1) (snd $1) And (snd $3))
}
| Expr3 {
    $1
}

Expr1 :: { (Pos, Expr Pos) }
Expr1
: Expr2 '||' Expr1 {
    (fst $1, AbsSPL.EBinOp (fst $1) (snd $1) Or (snd $3))
}
| Expr2 'or' Expr1 {
    (fst $1, AbsSPL.EBinOp (fst $1) (snd $1) Or (snd $3))
}
| Expr2 {
    $1
}

Expr :: { (Pos, Expr Pos) }
Expr
: 'new' CIdent '(' ListExpr ')' {
    (Just (tokenLineCol $1), AbsSPL.EObjNew (Just (tokenLineCol $1)) (snd $2) (snd $4))
}
| 'new' Type '[' Expr ']' {
    (Just (tokenLineCol $1), AbsSPL.EArrNew (Just (tokenLineCol $1)) (snd $2) (snd $4))
}
| '\\' ListArgument '->' LambdaExpr {
    (Just (tokenLineCol $1), AbsSPL.ELambda (Just (tokenLineCol $1)) (snd $2) (snd $4))
}
| '[' ListExpr ']' {
    (Just (tokenLineCol $1), AbsSPL.EArray (Just (tokenLineCol $1)) (snd $2))
}
| Expr1 {
    $1
}

ListExpr :: { (Pos, [Expr Pos]) }
ListExpr
: {- empty -} {
    (Nothing, [])
}
| Expr {
    (fst $1, [snd $1])
}
| Expr ',' ListExpr {
    (fst $1, (snd $1):(snd $3))
}

LambdaExpr :: { (Pos, Stmt Pos) }
LambdaExpr
: Expr {
    (fst $1, AbsSPL.Ret (fst $1) (snd $1))
}
| 'if' Expr 'then' LambdaExpr 'else' LambdaExpr {
    (Just (tokenLineCol $1), AbsSPL.CondElse (Just (tokenLineCol $1)) (snd $2) (snd $4) (snd $6))
}
| Block {
    (fst $1, AbsSPL.BStmt (fst $1) (snd $1))
}

{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    t:_ -> " before '" ++ id(prToken t) ++ "'"

myLexer = tokens

parseProgram :: [Token] -> Err (Program Pos)
parseProgram = (>>= return . snd) . pProgram

}

